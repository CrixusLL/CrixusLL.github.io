<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Leland&#39;s Blog</title>
  
  
  <link href="https://crixusll.github.io/atom.xml" rel="self"/>
  
  <link href="https://crixusll.github.io/"/>
  <updated>2023-08-09T10:02:01.494Z</updated>
  <id>https://crixusll.github.io/</id>
  
  <author>
    <name>Leland Lau</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="https://crixusll.github.io/2023/08/09/hello-world/"/>
    <id>https://crixusll.github.io/2023/08/09/hello-world/</id>
    <published>2023-08-09T10:02:01.494Z</published>
    <updated>2023-08-09T10:02:01.494Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>. Bye!</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>2023华为软件精英挑战赛笔记心得（Python实现）</title>
    <link href="https://crixusll.github.io/2023/03/31/2023%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%94%E8%AE%B0%E5%BF%83%E5%BE%97%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/"/>
    <id>https://crixusll.github.io/2023/03/31/2023%E5%8D%8E%E4%B8%BA%E8%BD%AF%E4%BB%B6%E7%B2%BE%E8%8B%B1%E6%8C%91%E6%88%98%E8%B5%9B%E7%AC%94%E8%AE%B0%E5%BF%83%E5%BE%97%EF%BC%88Python%E5%AE%9E%E7%8E%B0%EF%BC%89/</id>
    <published>2023-03-31T03:28:25.000Z</published>
    <updated>2024-03-30T12:35:49.581Z</updated>
    
    <content type="html"><![CDATA[<p>第一次参加华为软挑，问了周围一圈人没人组队，看了眼题目，感觉挺有意思的，就打算自己写来跑一下，不求分数，主要是想学点东西，顺便记录一下。（最后跑了195w+，自己的能力也就到这了）<img src="https://img-blog.csdnimg.cn/44dd3c500e694cbeb265cde7d961d4bc.png#pic_center" alt="菜 捞捞"><br>@[toc]</p><h2 id="1-题目概述"><a href="#1-题目概述" class="headerlink" title="1. 题目概述"></a>1. 题目概述</h2><p>本次比赛模拟了多机器人的运行环境以及真实机器人的状态信息。选手需要操控4个机器人执行前进、后退、旋转、购买、出售等动作来完成物品递送任务，同时赚取差价获得利润。在3分钟时间内，选手最后拥有的资金数（初始200000）即为最终分数，所获资金越高越好。<br><img src="https://img-blog.csdnimg.cn/52b8a9364b81429da5e24d7929363daa.png#pic_center" alt="比赛官方术语说明"><br>篇幅有限，题目就介绍到这里了，还有很多细节方面的介绍没写出来，想了解具体题目的朋友可以自行百度搜索也可以私信我。</p><h2 id="2-输入输出-amp-判题流程"><a href="#2-输入输出-amp-判题流程" class="headerlink" title="2. 输入输出 &amp; 判题流程"></a>2. 输入输出 &amp; 判题流程</h2><p><img src="https://img-blog.csdnimg.cn/3047c47237be44519bbb7d0bec6f82f0.png#pic_center" alt="选手程序与判题器交互过程"><br>大致流程如图，我们需要和判题器进行多次交互，判题器负责发送<strong>地图数据以及每一帧的信息（场上机器人、工作台的实时参数）</strong>，我们需要给判题器发送<strong>机器人控制指令</strong>，双方都以”OK”来作为信息发送的结束标志。来结合官方给的demo代码来理解一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read_util_ok</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">input</span>() != <span class="string">&quot;OK&quot;</span>:  <span class="comment">#从标准输入中读取一行数据直至读到&quot;OK&quot;</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">finish</span>():</span><br><span class="line">    sys.stdout.write(<span class="string">&#x27;OK\n&#x27;</span>)  <span class="comment">#选手发送&quot;OK&quot;指令</span></span><br><span class="line">    sys.stdout.flush()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    read_util_ok()<span class="comment">#此处为读取地图数据</span></span><br><span class="line">    finish()<span class="comment">#选手发送OK表示已接收到地图数据</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#循环直至时间结束</span></span><br><span class="line">        line = sys.stdin.readline()<span class="comment">#读取第一行（为帧序号以及当前金钱数）</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:<span class="comment">#3分钟倒计时结束后判题器不再发送任何信息</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        parts = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        frame_id = <span class="built_in">int</span>(parts[<span class="number">0</span>])<span class="comment">#获取当前帧序号（1-9000）</span></span><br><span class="line">        read_util_ok()<span class="comment">#继续获取剩余行数据</span></span><br><span class="line"><span class="comment">#以下是官方写的一部分操作（其实就是让机器人原地旋转...）</span></span><br><span class="line">        sys.stdout.write(<span class="string">&#x27;%d\n&#x27;</span> % frame_id)</span><br><span class="line">        line_speed, angle_speed = <span class="number">3</span>, <span class="number">1.5</span></span><br><span class="line">        <span class="keyword">for</span> robot_id <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">            sys.stdout.write(<span class="string">&#x27;forward %d %d\n&#x27;</span> % (robot_id, line_speed))</span><br><span class="line">            sys.stdout.write(<span class="string">&#x27;rotate %d %f\n&#x27;</span> % (robot_id, angle_speed))</span><br><span class="line">        finish()<span class="comment">#选手发送&quot;OK&quot;表示控制命令结束</span></span><br></pre></td></tr></table></figure><h2 id="3-思路分析"><a href="#3-思路分析" class="headerlink" title="3. 思路分析"></a>3. 思路分析</h2><p>这是一个多对象多决策的程序，涉及到机器人运动学和运筹学，对我来说都是全新领域，只能从头开始探索了。我打算化繁为简，先关注以下几个问题：</p><ul><li><strong>如何构建地图网络？如何分析判题器发送给你的数据？</strong></li><li><strong>如何让机器人移动（前进后退旋转）到指定工作台？</strong></li><li><strong>如何设计寻路、调度策略使得资金最大化？</strong></li></ul><p>这几个问题是最基本也是最核心的问题，不过光想没有用，一定要结合本地地图数据和判题器来进行模拟调试，才知道具体的交互过程是怎么样的。</p><p>小弟使用VSCode来进行程序编写，由于是需要通过外部判题器来执行python程序，因此调试需要将python附加到具体的判题器进程中，才能够断点debug，可以参考：<br><a href="https://blog.csdn.net/Leland_Lau/article/details/129655798">VSCode Python程序附加到进程debug</a></p><h2 id="4-详细分析"><a href="#4-详细分析" class="headerlink" title="4. 详细分析"></a>4. 详细分析</h2><h3 id="4-1-地图类构建以及读取地图、更新场上信息"><a href="#4-1-地图类构建以及读取地图、更新场上信息" class="headerlink" title="4.1 地图类构建以及读取地图、更新场上信息"></a>4.1 地图类构建以及读取地图、更新场上信息</h3><p>我考虑的是先构建一个全局控制的类，记录地图信息，包括机器人和工作台的各种信息等，通过这个类可以读取到任何物体的所有信息，我取名为Map类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Map</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.worktable_num = <span class="number">0</span><span class="comment">#工作台总数</span></span><br><span class="line">        self.robots = []<span class="comment">#机器人实体（按地图初始读入顺序排序）</span></span><br><span class="line">        self.worktables_list = []  <span class="comment"># 工作台实体（按地图初始读入顺序排序）</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">#每种类别的物品当前时刻可以添加到指定工作台的编号，如1:[2,4,6]表示编号2、4、6号工作台当前原材料需要1号物品</span></span><br><span class="line">        self.wt_to_be_added = &#123;<span class="number">1</span>:[], <span class="number">2</span>:[], <span class="number">3</span>:[], <span class="number">4</span>:[], <span class="number">5</span>:[], <span class="number">6</span>:[], <span class="number">7</span>:[]&#125;</span><br><span class="line">        <span class="comment">#原材料工作台已生产出成品的编号，如[2,4,6]表示第2、4、6号工作台当前已生产出原材料（1-3号的一种）</span></span><br><span class="line">        self.wt_to_be_purchased_123 = []</span><br><span class="line">        <span class="comment">#加工工作台已生产出成品的编号，值含义同上</span></span><br><span class="line">        self.wt_to_be_purchased_4567 = []</span><br></pre></td></tr></table></figure><p>当然，还得创建<strong>机器人</strong>和<strong>工作台</strong>两个类，顾名思义，类里面记录他们所有参数信息以及定义了一些功能函数（比如机器人的移动、工作台的判断机制等）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#篇幅所限，不把全部的代码粘上来了</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Robot</span>():</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.<span class="built_in">id</span> = -<span class="number">1</span></span><br><span class="line">self.on_task_dest = -<span class="number">1</span><span class="comment">#当前去往的工作台编号</span></span><br><span class="line">self.task = <span class="number">0</span><span class="comment">#当前执行任务的信息：1 buy, 2 sell, 3 destory</span></span><br><span class="line"><span class="comment">#还有机器人的位置、运动参数等属性不一一列出了</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, line_speed</span>):</span><br><span class="line">        sys.stdout.write(<span class="string">&#x27;forward %d %f\n&#x27;</span> % (self.<span class="built_in">id</span>, line_speed))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">rotate</span>(<span class="params">self, angle_speed</span>):</span><br><span class="line">        sys.stdout.write(<span class="string">&#x27;rotate %d %f\n&#x27;</span> % (self.<span class="built_in">id</span>, angle_speed))</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">buy</span>(<span class="params">self</span>):</span><br><span class="line">        sys.stdout.write(<span class="string">&#x27;buy %d\n&#x27;</span> % self.<span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sell</span>(<span class="params">self</span>):</span><br><span class="line">        sys.stdout.write(<span class="string">&#x27;sell %d\n&#x27;</span> % self.<span class="built_in">id</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">destroy</span>(<span class="params">self</span>):</span><br><span class="line">        sys.stdout.write(<span class="string">&#x27;destroy %d\n&#x27;</span> % self.<span class="built_in">id</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Worktable</span>():</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">self.<span class="built_in">id</span> = -<span class="number">1</span></span><br><span class="line">self.on_task_robot = -<span class="number">1</span><span class="comment">#当前占用此工作台的机器人编号</span></span><br><span class="line">self.get_info(<span class="built_in">type</span>)</span><br><span class="line"><span class="comment">#还有工作台的位置、生产状态等属性不一一列出了</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_info</span>(<span class="params">self, <span class="built_in">type</span></span>):<span class="comment">#通过工作台的类型来初始化一些信息（如需要的原材料类型、生产出来的物品类型、工作周期等等）</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>看了一眼地图，是100行*100列的txt数据，里面工作台用数字1-9表示，机器人用A表示，其余区域用.表示。直接写个函数循环读取就完事了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_map</span>():</span><br><span class="line">    map_info = Map()<span class="comment">#创建Map对象</span></span><br><span class="line">    row = <span class="number">0</span></span><br><span class="line">    worktable_num = <span class="number">0</span></span><br><span class="line">    robot_count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#按行读取</span></span><br><span class="line">        col = <span class="number">0</span></span><br><span class="line">        line = <span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">&quot;OK&quot;</span>:</span><br><span class="line">            map_info.worktable_num = worktable_num</span><br><span class="line">            <span class="keyword">return</span> map_info<span class="comment">#返回初始地图信息</span></span><br><span class="line">        <span class="keyword">for</span> char <span class="keyword">in</span> line:</span><br><span class="line">            <span class="keyword">if</span> char &gt;= <span class="string">&quot;1&quot;</span> <span class="keyword">and</span> char &lt;= <span class="string">&quot;9&quot;</span>:<span class="comment">#工作台</span></span><br><span class="line">                worktable = Worktable(<span class="built_in">int</span>(char))</span><br><span class="line">                worktable.<span class="built_in">id</span> = worktable_num<span class="comment">#跟判题器发送的顺序同步，即按照地图读取的顺序依次给工作台编号</span></span><br><span class="line">                worktable.loc = np.array([<span class="number">0.25</span>+col*<span class="number">0.5</span>, <span class="number">49.75</span>-row*<span class="number">0.5</span>])<span class="comment">#中心点坐标</span></span><br><span class="line">                map_info.worktables_list.append(worktable)</span><br><span class="line">                worktable_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> char == <span class="string">&quot;A&quot;</span>:<span class="comment">#机器人</span></span><br><span class="line">                robot = Robot()</span><br><span class="line">                robot.<span class="built_in">id</span> = robot_count</span><br><span class="line">                robot.loc = np.array([<span class="number">0.25</span>+col*<span class="number">0.5</span>, <span class="number">49.75</span>-row*<span class="number">0.5</span>])<span class="comment">#中心点坐标</span></span><br><span class="line">                map_info.robots.append(robot)</span><br><span class="line">                robot_count += <span class="number">1</span></span><br><span class="line">            col += <span class="number">1</span></span><br><span class="line">        row += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>地图创建好了，接下来就可以正式开始读取每一帧的数据了，我最后的主函数是这个样子的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    map_info = read_map()<span class="comment">#接受返回的地图读取数据信息</span></span><br><span class="line">    finish()</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:<span class="comment">#读取每一帧信息</span></span><br><span class="line">        line = sys.stdin.readline()</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        parts = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        frame_id = <span class="built_in">int</span>(parts[<span class="number">0</span>]) <span class="comment">#帧序号</span></span><br><span class="line">        map_info.money = <span class="built_in">int</span>(parts[<span class="number">1</span>])</span><br><span class="line">        read_util_ok()<span class="comment">#读取剩余信息</span></span><br><span class="line">        sys.stdout.write(<span class="string">&#x27;%d\n&#x27;</span> % frame_id)</span><br><span class="line">        task_manager()<span class="comment">#任务分配函数</span></span><br><span class="line">        action()<span class="comment">#命令控制函数</span></span><br><span class="line">        finish()</span><br></pre></td></tr></table></figure><p>这里的逻辑其实挺简单，地图数据读取完后，开始读取每一帧的数据，我是想着4个机器人，要在这么多个工作台之间往返，进行多种操作，那必须得有一个总的<strong>任务分配机制</strong>，用于调度具体的机器人去哪一个工作台干什么，所以写了一个task_manager()。分配完成以后，action()函数就是用来根据具体任务来控制机器人的移动的，然后这一帧就结束了。<br><strong>且慢，</strong> 我们先来看看read_util_ok()里面写了啥：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_util_ok</span>():</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        worktable_total = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line">        <span class="keyword">for</span> worktable_id <span class="keyword">in</span> <span class="built_in">range</span>(worktable_total):<span class="comment">#先遍历每一个工作台</span></span><br><span class="line">            line = <span class="built_in">input</span>()</span><br><span class="line">            parts = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            map_info.worktables_list[worktable_id].remaining_time = <span class="built_in">int</span>(</span><br><span class="line">                parts[<span class="number">3</span>])<span class="comment">#剩余生产时间</span></span><br><span class="line">            map_info.worktables_list[worktable_id].raw_material_status = <span class="built_in">bin</span>(<span class="built_in">int</span>(parts[<span class="number">4</span>]))[</span><br><span class="line">                ::-<span class="number">1</span>][:-<span class="number">2</span>].ljust(<span class="number">8</span>, <span class="string">&quot;0&quot;</span>)<span class="comment">#原材料格状态</span></span><br><span class="line">            map_info.worktables_list[worktable_id].production_status = <span class="built_in">int</span>(</span><br><span class="line">                parts[<span class="number">5</span>])<span class="comment">#产品格状态</span></span><br><span class="line">            <span class="comment"># 更新空闲工作台（待添加材料or待被购买成品）</span></span><br><span class="line">            <span class="keyword">if</span> map_info.worktables_list[worktable_id].on_task_robot == -<span class="number">1</span>:<span class="comment">#-1指当前工作台没有被机器人占用</span></span><br><span class="line">            <span class="comment">#先更新待添加材料的工作台（也就是4-9号）</span></span><br><span class="line">                <span class="keyword">if</span> parts[<span class="number">0</span>] <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]:</span><br><span class="line">                    map_info.worktables_list[worktable_id].to_be_added()</span><br><span class="line">                <span class="comment">#再更新待被购买成品的工作台（这里4-7号优先级高于1-3号）</span></span><br><span class="line">                <span class="keyword">if</span> parts[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>]:</span><br><span class="line">                    <span class="keyword">if</span> worktable_id <span class="keyword">not</span> <span class="keyword">in</span> map_info.wt_to_be_purchased_123:<span class="comment">#先判断是否已经在待购买的列表里了（其实这里也可以用set之类的确保不重复）</span></span><br><span class="line">                        <span class="keyword">if</span> map_info.worktables_list[worktable_id].to_be_purchased(): <span class="comment">#判断是否可以购买了</span></span><br><span class="line">                            map_info.wt_to_be_purchased_123.append(worktable_id)</span><br><span class="line">                <span class="keyword">elif</span> parts[<span class="number">0</span>] <span class="keyword">in</span> [<span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>]:</span><br><span class="line">                    <span class="keyword">if</span> worktable_id <span class="keyword">not</span> <span class="keyword">in</span> map_info.wt_to_be_purchased_4567:<span class="comment">#含义同上</span></span><br><span class="line">                        <span class="keyword">if</span> map_info.worktables_list[worktable_id].to_be_purchased():<span class="comment">#含义同上</span></span><br><span class="line">                            map_info.wt_to_be_purchased_4567.append(worktable_id)</span><br><span class="line">        <span class="keyword">for</span> robot_id <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):<span class="comment">#再遍历每一个机器人</span></span><br><span class="line">            line = <span class="built_in">input</span>()</span><br><span class="line">            parts = line.split(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            map_info.robots[robot_id].worktableID = <span class="built_in">int</span>(parts[<span class="number">0</span>])<span class="comment">#所处工作台ID</span></span><br><span class="line">            map_info.robots[robot_id].goods_type = <span class="built_in">int</span>(parts[<span class="number">1</span>])<span class="comment">#携带物品类型</span></span><br><span class="line">            map_info.robots[robot_id].time_coef = <span class="built_in">float</span>(parts[<span class="number">2</span>])<span class="comment">#时间价值系数</span></span><br><span class="line">            map_info.robots[robot_id].collision_coef = <span class="built_in">float</span>(parts[<span class="number">3</span>])<span class="comment">#碰撞价值系数</span></span><br><span class="line">            map_info.robots[robot_id].angle_speed = <span class="built_in">float</span>(parts[<span class="number">4</span>])<span class="comment">#角速度</span></span><br><span class="line">            map_info.robots[robot_id].line_speed = (</span><br><span class="line">                <span class="built_in">float</span>(parts[<span class="number">5</span>]), <span class="built_in">float</span>(parts[<span class="number">6</span>]))<span class="comment">#线速度</span></span><br><span class="line">            map_info.robots[robot_id].orientation = <span class="built_in">float</span>(parts[<span class="number">7</span>])<span class="comment">#朝向</span></span><br><span class="line">            map_info.robots[robot_id].loc = np.array(</span><br><span class="line">                [<span class="built_in">float</span>(parts[<span class="number">8</span>]), <span class="built_in">float</span>(parts[<span class="number">9</span>])])<span class="comment">#坐标</span></span><br><span class="line">        line = <span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> line == <span class="string">&quot;OK&quot;</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><p>其实就是读取每一帧工作台和机器人的实时信息。需要注意的是，工作台这边有一个<strong>原材料格状态</strong>是用二进制位表来描述的，为了方便读取状态，我这里每个工作台统一初始化状态为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Worktable</span>():</span><br><span class="line">self.raw_material_status = <span class="string">&#x27;00000000&#x27;</span></span><br></pre></td></tr></table></figure><p>因为原材料物品只有1-7，为方便操作，0号位就空出来，1-7号位分别代表1-7号物品的状态，0是待添加，1是已添加 <strong>（注意要对应具体类型的工作台需要的原材料类别）</strong><br><img src="https://img-blog.csdnimg.cn/b4c725613d0749b994e2e016c6c794ed.png#pic_center" alt="工作台类型说明"><br>到此为止，我们已经把每一帧场上的信息读取完成并更新了，当然，上面贴的代码是最终的版本，刚开始写肯定没有这么复杂，尤其是工作台那几个判断…</p><h3 id="4-2-任务分配机制"><a href="#4-2-任务分配机制" class="headerlink" title="4.2 任务分配机制"></a>4.2 任务分配机制</h3><p>这一步是整个比赛最关键的两个步骤之一，小弟不才，感觉这一步应该有很多很牛的分配调度算法，这里我只讲讲我自己的想法吧~</p><p>首先前面在读取每一帧信息后，其实我已经把空闲工作台放列表里了（其实严谨一点应该用队列，官方除了numpy不让调其他库，故只能用list简单模拟一下queue），对于每一个<strong>空闲</strong>的机器人，你无非就只能给它分配三个任务：<br> <strong>1. 去工作台购买材料，前提是机器人手上没有物品且该工作台已有成品；<br> 2. 去工作台出售材料，前提是机器人手上有物品且该工作台原材料格对应的材料状态为”0”；<br> 3. 销毁机器人当前手中的物品。</strong></p><p> 对于第1个任务，高级一点的算法可以计算机器人到工作台的距离和剩余生产时间的关系，比如差不多生产完了机器人就可以直接出发等等，但是对我来说太复杂了于是就把这个过程简化了，<strong>即当工作台产品格状态为”1”时，我才会让机器人出发去购买。</strong><br> 当分配了<strong>购买材料</strong>的任务后，需要马上进行以下信息的更新：</p><blockquote><p>①将该工作台从<strong>待被购买列表</strong>中移除，即self.wt_to_be_purchased_123 or 4567；<br>②更新机器人<strong>当前去往的工作台编号</strong>，即self.on_task_dest；<br>③更新机器人<strong>当前执行任务的信息</strong>，即self.task &#x3D; 1；<br>④更新工作台当前<strong>被占用的机器人编号</strong>，即self.on_task_robot</p></blockquote><p>对于第2个任务，先看看机器人手上拿着什么物品，然后去对应的工作台队列提取一个空闲的出来，因此在机器人类里面，我写了一个映射的函数，即机器人持有物品类型应该去哪几个工作台出售：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_optional_wt</span>(<span class="params">self</span>):</span><br><span class="line">        ori_material = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]<span class="comment">#持有物品类型</span></span><br><span class="line">        optional_worktables = [</span><br><span class="line">            [], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>], [<span class="number">4</span>, <span class="number">6</span>, <span class="number">9</span>], [<span class="number">5</span>, <span class="number">6</span>, <span class="number">9</span>], [<span class="number">7</span>, <span class="number">9</span>], [<span class="number">7</span>, <span class="number">9</span>], [<span class="number">7</span>, <span class="number">9</span>], [<span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">        ]<span class="comment">#对应的可选择工作台（0号位置空）</span></span><br><span class="line">        self.optional_wt = optional_worktables[ori_material[self.goods_type]]</span><br></pre></td></tr></table></figure><p>注意，还需要判断这个空闲的工作台是否真的“空闲”，即原材料格对应物品的状态为”0”。<strong>如果遍历完所有工作台没有符合的，则更改为第3个任务，即销毁，在下一帧重新进入空闲池，重新分配任务。只需要将self.task赋值为3即可。</strong><br>否则，当分配了<strong>出售物品</strong>的任务后，需要马上进行以下信息的更新：</p><blockquote><p>①将该工作台从<strong>待被购买列表</strong>中移除，即self.wt_to_be_added；<br>②更新机器人<strong>当前去往的工作台编号</strong>，即self.on_task_dest；<br>③更新机器人<strong>当前执行任务的信息</strong>，即self.task &#x3D; 2；<br>④更新工作台当前<strong>被占用的机器人编号</strong>，即self.on_task_robot</p></blockquote><p>可以看到，同一个工作台只能被一个机器人占用，占用结束后（出售完成or购买完成）才能被其他机器人占用。我知道这样子效率肯定大打折扣，但目前来说，可以先这样子执行，后面有时间可以进一步<strong>优化</strong>，毕竟如果同时有多个机器人占用工作台，可能会出现大量机器人聚集在同一个工作台附近，无法操作~</p><h3 id="4-3-控制机器人移动、执行任务和重置"><a href="#4-3-控制机器人移动、执行任务和重置" class="headerlink" title="4.3 控制机器人移动、执行任务和重置"></a>4.3 控制机器人移动、执行任务和重置</h3><p>这一步同样是非常重要的一步，涉及到大量的有关物理引擎方面的知识，网上也有很多现成的算法可以拿来用，不过我还是选择先自己研究一下~<br><img src="https://img-blog.csdnimg.cn/0def2e9e9d7049af8d0f4c775ff7ca53.png#pic_center" alt="机器人控制运动指令"><br>通过replayer大量回放，我发现当输出一个指令时，比如forward，机器人的速度不是突变的，而是在极短时间内通过恒定加速度从初速度$V_0$变到末速度$V_t$，再去看一眼官方文档，可以发现：<br><img src="https://img-blog.csdnimg.cn/eaa27d6a844c4f03ab4643b0656e5c97.png#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/5195e7dc8ef4426fb11234e25d5e8ffa.png#pic_center" alt="机器人一些属性定义"><br>有<strong>最大牵引力</strong>这么一个玩意，这就说明机器人从$V_0$到$V_t$所经过的位移其实是要用积分去算的…哈哈，此处忽略，尽可能简化！我们先来看看机器人最大加速度是多少（如有计算错误请在评论区指出，感激不尽！)。</p><blockquote><p>物体质量 &#x3D; 面积*密度，即$m&#x3D;\pi R^2\times\rho&#x3D;12.72kg$（未携带物品）or $17.65kg$（携带物品）；<br>$F&#x3D;ma$，不考虑阻力，则$F$为牵引力；<br>$a_{max}&#x3D;F_{max}&#x2F;m&#x3D;19.65(m&#x2F;s^2)$ （未携带物品）or $14.16(m&#x2F;s^2)$（携带物品）</p></blockquote><p>加速度有啥用呢？比如机器人正全速朝一个工作台飞奔过去，当快到的时候，就可以算出当距离工作台还有多少米的时候可以开始减速以至于到达工作台的时候，速度降为0（或者低速，因为官方demo是低速经过工作台并完成买卖操作的，没有完全停下）。我们来考虑这样一个情况：</p><blockquote><p>已知机器人初速度为$6m&#x2F;s$，末速度是$0m&#x2F;s$（模拟减速的过程）；<br>最大加速度为$-19.65(m&#x2F;s^2)$ or $-14.16(m&#x2F;s^2)$；<br>根据$V_t^2&#x3D;V_0^2+2as$，机器人需要经过0.92米（未携带物品）或1.27米（携带物品）才能够停下来；<br>根据$V_t&#x3D;V_0+at$，机器人停下来所需时间为0.31秒（未携带物品）或0.42秒（携带物品）</p></blockquote><p>因此，我们可以预留1.27米以上的距离来让机器人进行减速，所需时长为16~21帧左右。</p><p>在看<strong>最大力矩</strong>之前，我们先来看看机器人<strong>导航</strong>的问题。一开始笔者以为需要用到类似迪杰斯特拉或者A*这一类的寻路算法，但后来发现由于地图没有障碍物，而且物理引擎模拟运动的时候朝向是可以360°的，因此可以简化问题，我们只需要算出机器人和工作台的航向角，就可以通过控制<strong>角速度</strong>让机器人转到合适的角度，然后<strong>全速直线前进</strong>！</p><p>因此，我写了一个计算<strong>两个物体之间距离以及航向角</strong>的函数，比较简单粗暴，大家可以先看看这位大佬的分析：<a href="https://zhuanlan.zhihu.com/p/612863940">https://zhuanlan.zhihu.com/p/612863940</a><br><img src="https://img-blog.csdnimg.cn/f5a8cee4d12c49f8a1106bb0765b4147.png#pic_center" alt="航向角计算"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dist</span>(<span class="params">ori, dest</span>):<span class="comment">#ori是源坐标，dest是目标坐标</span></span><br><span class="line">    dist = np.sqrt(np.<span class="built_in">sum</span>(np.square(dest - ori)))<span class="comment">#欧式距离</span></span><br><span class="line">    delta_x = dest[<span class="number">0</span>] - ori[<span class="number">0</span>]</span><br><span class="line">    delta_y = dest[<span class="number">1</span>] - ori[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> delta_x * delta_y == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> delta_x:</span><br><span class="line">            ori_to_dest_radian = <span class="number">0</span> <span class="keyword">if</span> delta_x &gt; <span class="number">0</span> <span class="keyword">else</span> np.pi</span><br><span class="line">        <span class="keyword">elif</span> delta_y:</span><br><span class="line">            ori_to_dest_radian = np.pi / <span class="number">2</span> <span class="keyword">if</span> delta_y &gt; <span class="number">0</span> <span class="keyword">else</span> -np.pi/<span class="number">2</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ori_to_dest_radian = <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span> delta_x &gt; <span class="number">0</span>:</span><br><span class="line">        ori_to_dest_radian = np.arctan(delta_y/delta_x)</span><br><span class="line">    <span class="keyword">elif</span> delta_x &lt; <span class="number">0</span>:</span><br><span class="line">        tmp_radian = np.arctan(delta_y/delta_x)</span><br><span class="line">        ori_to_dest_radian = tmp_radian + np.pi <span class="keyword">if</span> tmp_radian &lt; <span class="number">0</span> <span class="keyword">else</span> tmp_radian - np.pi</span><br><span class="line">    <span class="keyword">return</span> dist, ori_to_dest_radian</span><br></pre></td></tr></table></figure><p>在这里，我列举出8个目标方位dest来计算和源坐标ori的关系，通过x和y维度距离差和arctan函数计算出源坐标朝向目标坐标的<strong>朝向角</strong>，结合图片看代码应该比较好理解。</p><p>至此，我们算出了朝向角α（弧度），通过每一帧的信息读取我们能获取每个机器人当前的朝向β（弧度），范围[-π,π]。接下来要算的就是怎么让机器人从β转到α，可以顺时针（角速度为负）转也可以逆时针转（角速度为正）。显然，为了时间效率，我们要算出朝哪个方向转用时更少：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delta_radian = dest_radian - ori_radian</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">abs</span>(delta_radian) &gt; np.pi:</span><br><span class="line">delta_radian = delta_radian + \</span><br><span class="line">   <span class="number">2</span> * np.pi <span class="keyword">if</span> delta_radian &lt; <span class="number">0</span> <span class="keyword">else</span> delta_radian - <span class="number">2</span> * np.pi</span><br></pre></td></tr></table></figure><p>当二者朝向弧度绝对值相差<strong>不超过π</strong>时，那么就取它原来的值，如果是正数就逆时针转，如果是负数就顺时针转。而如果弧度相差<strong>超过π</strong>时，我们就要算出朝另一个方向转相差的弧度，比如机器人当前面向y轴正方向（也就是90°，π&#x2F;2弧度），工作台在它的左下角45°位置，即朝向角为225°（-3π&#x2F;4弧度），此时二者相差弧度delta_radian为|-5π&#x2F;4| &gt; π，那么只需要让delta_radian加上2π也就是等于3π&#x2F;4就行。即相同旋转速度下机器人逆时针旋转3π&#x2F;4（135°）比顺时针旋转5π&#x2F;4（225°）要更快。同理，当相差弧度delta_radian为正数时，就要让它减去2π。</p><p>根据角速度的定义，我们知道相差弧度，只需要将其除以时间就能够得到对应的角速度，但这个时间怎么确定呢？简单粗暴一点的方法是，由于一帧是0.02秒，那么我只需要让它在这0.02秒内旋转到我想要的方向就可以了呀！<strong>但是！</strong> 别忘了前面提到的<strong>最大力矩</strong>，这其实是跟转动角加速度有关系的。<strong>（如有错误烦请指正）</strong></p><blockquote><p>记力矩为M，角加速度为β，I为转动惯量，则$M&#x3D;I\times β$；<br>对于二维平面的圆形物体（当作薄圆盘），不考虑高度，则$I&#x3D;1&#x2F;2\times m\times r^2$. 其中m是物体质量，r是质点和转轴的垂直距离，此处为0.45米 or 0.53米。则$I&#x3D;1.29 (kg\cdot m^2)$ or $2.48 (kg\cdot m^2)$；<br>最大角加速度为$β_{max}&#x3D;M&#x2F;I&#x3D;38.76 (rad&#x2F;s^2)$（未携带物品） or $20.16(rad&#x2F;s^2)$（携带物品）</p></blockquote><p>跟直线运动类似，我们也可以计算出调整角速度合适的时机。比如，机器人初始面向x轴正方向，现在要旋转到y轴正方向，所需旋转的弧度为π&#x2F;2，如果用最大角加速度旋转，则需耗时0.28秒（未携带物品）或0.39秒（携带物品），等等。在这里我简化了旋转的场景，毕竟每一帧我都要判断当前朝向是否对着工作台，所以我就忽略了角加速度，统一以delta_radian &#x2F; 0.02作为旋转速度，这样子的后果就是如果旋转的角度过大，会出现左右轻微甩头现象，<strong>会损失一定的时间</strong>。</p><p>因此我的逻辑就比较简单，首先判断机器人和朝向和目标朝向相差的绝对值是否大于π&#x2F;2，若是，则低速旋转直至小于π&#x2F;2（如线速度可以设置为$3.5m&#x2F;s$）；如果小于π&#x2F;2则设置$6m&#x2F;s^2$的线速度。当离工作台距离还有1.27米的时候，设置线速度为$2m&#x2F;s$，当离工作台距离小于0.4米时（<strong>进入可操作距离范围</strong>），线速度设置为$0.8m&#x2F;s$，并执行买卖操作。</p><p>买卖完成后（<strong>如何确保完成？</strong> 详见下方优化部分），我们需要重置一些参数：</p><blockquote><p>①将机器人前往的工作台编号复位为-1，即self.on_task_dest &#x3D;  -1；<br>②将机器人当前任务复位为0，即self.task &#x3D; 0；<br>对于任务1和2，还需要重置：<br>③将工作台被占用的机器人编号复位为-1，即self.on_task_robot &#x3D; -1</p></blockquote><p>至此，action()函数执行完毕，同时当前帧的所有操作已完成。通过以上步骤，能确保写出一个能跑分的程序，只不过分数比较低！</p><h2 id="5-程序优化与提升"><a href="#5-程序优化与提升" class="headerlink" title="5. 程序优化与提升"></a>5. 程序优化与提升</h2><p>显然，上述各个步骤都会选择性地忽略一些东西，这样会导致时间效率比较低，在这里，我们可以针对性地去优化一些问题以提升所获资金。</p><h4 id="优化1、距离优先-x2F-利润优先原则"><a href="#优化1、距离优先-x2F-利润优先原则" class="headerlink" title="优化1、距离优先&#x2F;利润优先原则"></a>优化1、距离优先&#x2F;利润优先原则</h4><p>此优化用上了贪心的思想。在前面所述分配任务中，工作台待买卖队列是按照读取顺序依次加入的，因此机器人读取可选择工作台队列的时候也是相当于按工作台编号顺序依次遍历判断，这样就完全没有考虑距离和利润，导致机器人满图跑。</p><p>因此，在机器人遍历工作台的时候，我们不急着直接让第一个读取到的工作台出队，而是遍历完所有可用的工作台，然后进行一个<strong>距离远近排序和利润大小排序</strong>，可以给二者赋予相应的权重，然后类似打分机制算出<strong>综合距离和利润最优</strong>的那一个工作台（当然也可以直接相除，对<strong>利润&#x2F;距离</strong>进行排序并选择值最大的那一个），让其出队，再分别改变机器人和工作台相应的各个参数就好啦！（比赛中我只考虑了距离）</p><p>缺点：时间复杂度变大了，但是只要保证主程序能在15ms之内跑完就没太大问题。</p><h4 id="优化2、任务1和2合并"><a href="#优化2、任务1和2合并" class="headerlink" title="优化2、任务1和2合并"></a>优化2、任务1和2合并</h4><p>在初赛正式赛的时候，跑第4张图的分数特别低，于是打开replayer回放了n遍查原因，原来是因为地图里面有若干个6号工作台（生产6号物品），但收购6号物品的工作台只有1部7号工作台，无9号工作台，这就导致如果7号工作台中原材料格里面已经有6号物品了，那么当机器人手持6号物品时，会因为找不到可用的工作台，而执行任务3，也就是销毁（<strong>至少我的程序里是这么执行的，说不定可以写个等待函数之类的，但太复杂我就没研究了</strong>），而6号物品价值不菲，而且机器人很可能会在7号工作台进入生产周期之前多次购买6号物品并销毁，这就导致资金直线下滑…</p><p>所以，我重新架构了一下，将任务2与1合并，也就是说，我将<strong>待被购买</strong>工作台与<strong>待添加</strong>工作台捆绑在一起，比如编号1工作台生产2号物品，编号10工作台是类型6工作台，即收购2和3号物品作为原材料进行生产，当编号10工作台的原材料格子里面没有2号物品时，我将编号1和编号10进行<strong>捆绑</strong>。<strong>机器人分配去编号1工作台进行购买物品，当购买完成后，立即执行任务2，也就是前往编号10工作台出售物品。</strong> 这样就能避免当场上不需要某个物品时，机器人还硬要去购买的尴尬场面…</p><p>为了能体现出<strong>距离优先</strong>原则，编号1在捆绑编号10工作台之前，其实也是进行了距离排序的，比如当编号8、9、10工作台同时满足条件时，就会计算它们分别与编号1工作台的距离，距离最近的那一个才会与编号1进行捆绑。</p><p>当然了，由于这个改动比较大，因此不仅是task_manager()，action()部分也需要改动，这里就不放代码上来了，感兴趣的朋友可以私信我~</p><h4 id="优化3、确保机器人已购买-or-已出售"><a href="#优化3、确保机器人已购买-or-已出售" class="headerlink" title="优化3、确保机器人已购买 or 已出售"></a>优化3、确保机器人已购买 or 已出售</h4><p>理论上，只要不发生跳帧，是不用担心操作失败的，除非你允许两个及以上机器人对同一个工作台进行操作，那可能会发生冲突。</p><p>可以写一个check函数，并设置一些变量，比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">check</span>(<span class="params">robot_id</span>):</span><br><span class="line">    <span class="keyword">if</span> map_info.robots[robot_id].on_task_dest &gt; -<span class="number">1</span>:<span class="comment">#空闲机器人跳过此步骤</span></span><br><span class="line">        <span class="keyword">if</span> map_info.robots[robot_id].task == <span class="number">1</span>:    <span class="comment"># buy</span></span><br><span class="line">            <span class="keyword">if</span> map_info.robots[robot_id].goods_type == map_info.worktables_list[map_info.robots[robot_id].on_task_dest].production:</span><br><span class="line">                reset(robot_id)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                map_info.robots[robot_id].task = <span class="number">3</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        <span class="keyword">elif</span> map_info.robots[robot_id].task == <span class="number">2</span>:  <span class="comment"># sell</span></span><br><span class="line">            <span class="keyword">if</span> map_info.robots[robot_id].goods_type == <span class="number">0</span>:</span><br><span class="line">                reset(robot_id)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                map_info.robots[robot_id].task = <span class="number">3</span><span class="comment"># destroy</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>判断机器人已完成<strong>购买</strong>操作：购买完之后的下一帧判断机器人携带物品类型是否等于对应工作台生产物品的类型。若相等则进入重置函数reset（见上），否则销毁；</li><li>判断机器人已完成<strong>出售</strong>操作：出售完后的下一帧判断机器人携带物品类型是否为0，即没有携带物品。若是则进入重置函数reset（见上），否则销毁。</li></ul><h4 id="优化4、碰撞监测"><a href="#优化4、碰撞监测" class="headerlink" title="优化4、碰撞监测"></a>优化4、碰撞监测</h4><p>机器人难免会发生碰撞，我就试过多次两个机器人对撞而且还保持不动了（因为质量相同且朝向刚好相差π…），所以一定要有碰撞监测函数（成熟的算法很多，比如TEB和DWA），命名为collision_detect()，<strong>在action()函数输出机器人线速度和角速度之前，执行碰撞监测：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">collision_detect</span>(<span class="params">robot_id, delta_radian, line_speed</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">        <span class="keyword">if</span> i != robot_id:</span><br><span class="line">            d, _ = dist(map_info.robots[robot_id].loc, map_info.robots[i].loc)</span><br><span class="line">            <span class="keyword">if</span> d &lt; <span class="number">2.12</span> <span class="keyword">and</span> \</span><br><span class="line">                <span class="built_in">abs</span>(map_info.robots[robot_id].orientation) + <span class="built_in">abs</span>(map_info.robots[i].orientation) &gt; np.pi / <span class="number">2</span>:</span><br><span class="line">                delta_radian = (delta_radian + (robot_id + <span class="number">1</span>) * np.pi / <span class="number">4</span>) % np.pi - np.pi</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> delta_radian, line_speed</span><br></pre></td></tr></table></figure><p>这里比较粗暴，传入要检测的机器人id，然后遍历剩余机器人并与之进行判断。判断的方式也很粗暴，首先是二者的<strong>距离不能过近</strong>，这里有一个阈值，我设为2.12米（没啥科学依据），刚好是两个机器人中间还能再塞下一个机器人的距离，主要是为了留出足够时间和空间进行避让。其次，当二者的<strong>朝向绝对值的和大于π&#x2F;2</strong>时，便要主动避让，避让的方式就是在原朝向基础上随机让delta_radian发生改变，最大程度避免正面相撞！</p><p>事实上这个判断方式是<strong>有点问题</strong>的，如图所示，加入黄点和绿点同时朝y轴正方向移动，它们也会符合条件从而进行主动避让，但因为那时候比赛没顾及太多，想着这种情况几乎不可能出现。目前我有另外一个想法，就是先设置判定距离阈值，如2.12米，当机器人离另外一个机器人距离小于2.12米时进入判断，此时<strong>计算出机器人按当前速度运动一帧（0.02s）后离另一个机器人的距离是否变得更近</strong>，如果更近则采取主动避让措施。这个想法不难实现，但不知道会不会使效率更低抑或是出现新的bug……笔者也想了解更好的做法，欢迎交流噢~<br><img src="https://img-blog.csdnimg.cn/f5dd04e186aa48ef8cf187983f4056ac.png#pic_center" alt="碰撞监测"><br>更新：<br>b站上看到有大佬用机器人<strong>相对位置和速度</strong>来重新建系考虑是否碰撞，详情戳<a href="https://www.bilibili.com/video/BV1aN411P7ov/?t=927">https://www.bilibili.com/video/BV1aN411P7ov/?t=927</a></p><h4 id="优化5、考虑时间和碰撞价值系数"><a href="#优化5、考虑时间和碰撞价值系数" class="headerlink" title="优化5、考虑时间和碰撞价值系数"></a>优化5、考虑时间和碰撞价值系数</h4><p>我自始至终都没有考虑这两个系数，因为前面我用上了<strong>距离优先</strong>（确保用时不会过长）和<strong>碰撞监测</strong>（确保碰撞冲量不会过大）这两个机制。在这里，时间和碰撞价值系数最小值都是0.8，也就是说，物品售价最坏的情况就是0.8 * 0.8 * 原始售价，也就是打64折。对于1、2、3物品来说，还有得赚。但是4、5、6、7就容易出现亏损了，数字越大亏的越厉害，因此要针对4、5、6、7号物品设置<strong>亏损销毁机制</strong>。<br><img src="https://img-blog.csdnimg.cn/0100df7f86fd463d87cb0bcf70597eca.png#pic_center" alt="物品售价计算公式"></p><table><thead><tr><th>物品</th><th>购买价</th><th>原始售出价</th><th>最小系数之积（时间*碰撞）</th></tr></thead><tbody><tr><td>4</td><td>15400</td><td>22500</td><td>0.684</td></tr><tr><td>5</td><td>17200</td><td>25000</td><td>0.688</td></tr><tr><td>6</td><td>19200</td><td>27500</td><td>0.698</td></tr><tr><td>7</td><td>76000</td><td>105000</td><td>0.724</td></tr></tbody></table><p>不过我还是不太懂，就算7号物品打64折，也就亏个8800，如果销毁了不就直接没了76000？还是说这两个系数的存在不是为了让你销毁，而是转向其他的策略？</p><h4 id="优化6、优先卖出7号物品（未实现）"><a href="#优化6、优先卖出7号物品（未实现）" class="headerlink" title="优化6、优先卖出7号物品（未实现）"></a>优化6、优先卖出7号物品（未实现）</h4><p>我们知道7号物品的利润是最高的，不计时间和碰撞的损失，能达到29000！所以当7号类型工作台的原材料格未满时，我们应该<strong>优先填满</strong>并让其开始生产，这里可能需要多写几个判断，问题不大。</p><p>但要注意的是，由于机器人优先去7号类型工作台不一定是距离最优，因此时间快要结束的时候，我们需要判断机器人<strong>出发去买原材料的距离+去7号工作台出售物品的距离</strong>是否能在<strong>剩余比赛时间</strong>内走完，此时<strong>速度</strong>取最大值$6m&#x2F;s$。</p><h2 id="6-最终结果"><a href="#6-最终结果" class="headerlink" title="6. 最终结果"></a>6. 最终结果</h2><p><img src="https://img-blog.csdnimg.cn/dd9ca2f9ac6042ababe921d16d0fb968.png#pic_center" alt="最终跑分"><br>没想到是第一场分数相对来说比较低，其他几场的分数都提上去了，相比起榜上300w+的大佬我还差得远，通过这次比赛也算是对这方面有一个小小的入门吧。感觉用Python本身就没有C++有优势…</p><p><strong>比赛中存在的问题：</strong> 首先人数上就存在劣势，毕竟三个臭皮匠赛过诸葛亮嘛~其次是开始写程序的时间太晚了，10号开始的练习赛我19号才想起来报了名，浪费了整整9天时间&#x2F;(ㄒoㄒ)&#x2F;~~再有，正式赛的时候我只关注了4号地图，因为只有它分数比较低，针对4号地图存在的问题进行了一些优化（优化2），但其实应该4张图的回放都要看，针对不同地图需要不断改进才行，不然的话也不会最后时刻提交上去发现1号地图的分反而还下降了不少。最后就是写代码的习惯不太好，也不够规范，有时候不得不牵一发而动全身，效率自然也没有这么高了。</p><p><strong>欢迎大家交流想法，互相学习！！！</strong></p><blockquote><p>代码地址：<a href="%E4%BB%A3%E7%A0%81%E5%9C%B0%E5%9D%80%EF%BC%9Ahttps://github.com/CrixusLL/Huawei-CodeCraft-2023">https://github.com/CrixusLL/Huawei-CodeCraft-2023</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;第一次参加华为软挑，问了周围一圈人没人组队，看了眼题目，感觉挺有意思的，就打算自己写来跑一下，不求分数，主要是想学点东西，顺便记录一下。（最后跑了195w+，自己的能力也就到这了）&lt;img src=&quot;https://img-blog.csdnimg.cn/44dd3c500</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>My New Post</title>
    <link href="https://crixusll.github.io/2023/03/27/My-New-Post/"/>
    <id>https://crixusll.github.io/2023/03/27/My-New-Post/</id>
    <published>2023-03-27T11:46:45.000Z</published>
    <updated>2023-08-09T10:02:01.494Z</updated>
    
    <content type="html"><![CDATA[<p>abstract here!</p><span id="more"></span><h2 id="Good"><a href="#Good" class="headerlink" title="Good"></a>Good</h2><p>123456</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;abstract here!&lt;/p&gt;</summary>
    
    
    
    
    <category term="python" scheme="https://crixusll.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>VSCode Python程序附加到进程debug</title>
    <link href="https://crixusll.github.io/2023/03/19/VSCode%20Python%E7%A8%8B%E5%BA%8F%E9%99%84%E5%8A%A0%E5%88%B0%E8%BF%9B%E7%A8%8Bdebug/"/>
    <id>https://crixusll.github.io/2023/03/19/VSCode%20Python%E7%A8%8B%E5%BA%8F%E9%99%84%E5%8A%A0%E5%88%B0%E8%BF%9B%E7%A8%8Bdebug/</id>
    <published>2023-03-19T13:36:55.000Z</published>
    <updated>2024-03-30T12:40:53.465Z</updated>
    
    <content type="html"><![CDATA[<p>﻿## 背景</p><p>某个处于进程中的程序（如exe）需要调用python程序，如果运行python过程中想要实时调试，可以利用VSCode操作。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ol><li>首先确保正在运行的这个程序能让你调试，即如果是交互型的场景（如标准输入输出流），需要让程序进入debug模式；</li><li>Python程序（.py文件）里，在想要debug的代码前加入sleep，确保有足够的时间attach到进程，如：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">10</span>) <span class="comment">#时间自定义</span></span><br></pre></td></tr></table></figure><ol start="3"><li>VSCode按F5选择【使用ID进行附加】，也就是【Attach using process ID】<br><img src="https://img-blog.csdnimg.cn/5000a4742c4d4f30a40bf25d78621e8c.png#pic_center" alt="使用进程ID进行附加"></li><li>运行主程序，同时开启CMD输入： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklist | find &quot;python&quot;</span><br></pre></td></tr></table></figure>复制主程序调用的PID；或者直接去任务管理器查看主程序调用的python.exe的PID，<strong>注意不要和VSCode发起的python.exe混淆！</strong></li></ol><blockquote><p>如果有更好的方法烦请各位读者留言，感激不尽！</p></blockquote><ol start="5"><li>回到VSCode，在上方弹窗【选择要附加到的进程】中输入PID，回车即可。可以提前在代码块中设置断点，这样在attach之后就能进行debug了~</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;﻿## 背景&lt;/p&gt;
&lt;p&gt;某个处于进程中的程序（如exe）需要调用python程序，如果运行python过程中想要实时调试，可以利用VSCode操作。&lt;/p&gt;
&lt;h2 id=&quot;方法&quot;&gt;&lt;a href=&quot;#方法&quot; class=&quot;headerlink&quot; title=&quot;方法&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>扩展欧几里得求逆元步骤（手动+python求解）</title>
    <link href="https://crixusll.github.io/2020/03/27/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%B1%82%E9%80%86%E5%85%83%E6%AD%A5%E9%AA%A4%EF%BC%88%E6%89%8B%E5%8A%A8+python%E6%B1%82%E8%A7%A3%EF%BC%89/"/>
    <id>https://crixusll.github.io/2020/03/27/%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E6%B1%82%E9%80%86%E5%85%83%E6%AD%A5%E9%AA%A4%EF%BC%88%E6%89%8B%E5%8A%A8+python%E6%B1%82%E8%A7%A3%EF%BC%89/</id>
    <published>2020-03-27T08:52:02.000Z</published>
    <updated>2024-03-30T12:42:10.269Z</updated>
    
    <content type="html"><![CDATA[<p>学RSA的时候自己重新理解了一下扩展欧几里得，根据常见求逆元的相关代码，稍微总结了一下步骤，就分享出来叭~</p><h2 id="例子：701-1-mod-1848-x3D"><a href="#例子：701-1-mod-1848-x3D" class="headerlink" title="例子：701^(-1) mod 1848&#x3D;?"></a>例子：701^(-1) mod 1848&#x3D;?</h2><p>换言之，也就是701×?-1848×k&#x3D;1，k是系数，问号?即为701模1848的逆元.</p><h3 id="Step-1-amp-emsp-先用辗转相除法“求”701和1848的最大公因数gcd"><a href="#Step-1-amp-emsp-先用辗转相除法“求”701和1848的最大公因数gcd" class="headerlink" title="Step 1&amp;emsp;先用辗转相除法“求”701和1848的最大公因数gcd"></a>Step 1&amp;emsp;先用辗转相除法“求”701和1848的最大公因数gcd</h3><p>为什么这个求要加双引号呢？因为最大公因数有这样一条性质：</p><blockquote><p>设整数a,b不同时为零，则存在一对整数m,n，使得gcd(a.b) &#x3D; am+bn</p></blockquote><p>因此不用求也知道这两个数的gcd必然为1，否则无法求出逆元，我们要做的只是把求到1的过程列出来，方便后面用扩展欧几里得~<br>过程如图：<br><img src="https://img-blog.csdnimg.cn/20200327160838826.png#pic_center" alt="辗转相除法"></p><h3 id="Step-2-amp-emsp-推出相邻式子关系"><a href="#Step-2-amp-emsp-推出相邻式子关系" class="headerlink" title="Step 2&amp;emsp;推出相邻式子关系"></a>Step 2&amp;emsp;推出相邻式子关系</h3><p>根据</p><blockquote><p>gcd(a,b) &#x3D; gcd(b,a%b)</p></blockquote><p>已知：<br>gcd(a,b)&#x3D;a<font color=red><strong>x</strong></font>+b<font color=blue><strong>y</strong></font><br>a%b&#x3D;a-(a&#x2F;&#x2F;b)*b&amp;emsp;&amp;emsp;&#x2F;&#x2F;指取商的整数部分<br>gcd(b,a%b) &#x3D; bx’+(a-(a&#x2F;&#x2F;b)*b)*y’ &#x3D; a<font color=red><strong>y’</strong></font>+b<font color=blue><strong>(x’– a&#x2F;&#x2F;b*y’)</strong></font><br>推得：<br><strong>x &#x3D; y’<br> y &#x3D; x’ – a&#x2F;&#x2F;b*y’</strong><br>（其中x,y所在式子的下一条是x’,y’）</p><h3 id="Step-3-amp-emsp-扩展欧几里得"><a href="#Step-3-amp-emsp-扩展欧几里得" class="headerlink" title="Step 3&amp;emsp;扩展欧几里得"></a>Step 3&amp;emsp;扩展欧几里得</h3><p>从Step 1中最后得到的1和0我们可以列出a*1+b*0&#x3D;gcd(a,b)&#x3D;1这一式子，再根据Step 2推得的x&#x3D;y’可以一步一步往上代入，以此类推，从而推出每一步的因子x和y，顺序如下（从最底下往上推）：</p><p><img src="https://img-blog.csdnimg.cn/20200327163042654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0xlbGFuZF9MYXU=,size_16,color_FFFFFF,t_70#pic_center" alt="扩展欧几里得"><br>推到刚开始的1848和701后，我们得到y为29，即为所求的逆元.<br><strong>注意：如果得到的y为负数，需要取模才能得到逆元.</strong><br>容易验证：701×29 &#x3D; 1 (mod 1848)</p><p>以下为python代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">ext_gcd</span>(<span class="params">a, b</span>): <span class="comment">#扩展欧几里得算法    </span></span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:          </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>, <span class="number">0</span>, a     </span><br><span class="line">    <span class="keyword">else</span>:         </span><br><span class="line">        x, y, gcd = ext_gcd(b, a % b) <span class="comment">#递归直至余数等于0(需多递归一层用来判断)        </span></span><br><span class="line">        x, y = y, (x - (a // b) * y) <span class="comment">#辗转相除法反向推导每层a、b的因子使得gcd(a,b)=ax+by成立         </span></span><br><span class="line">        <span class="keyword">return</span> x, y, gcd</span><br></pre></td></tr></table></figure><p>以上述数据为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ext_gcd(<span class="number">1848</span>,<span class="number">701</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(-<span class="number">11</span>, <span class="number">29</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>完结撒花~！</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/destiny1507/article/details/81750874">扩展欧几里得算法详解</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;学RSA的时候自己重新理解了一下扩展欧几里得，根据常见求逆元的相关代码，稍微总结了一下步骤，就分享出来叭~&lt;/p&gt;
&lt;h2 id=&quot;例子：701-1-mod-1848-x3D&quot;&gt;&lt;a href=&quot;#例子：701-1-mod-1848-x3D&quot; class=&quot;headerli</summary>
      
    
    
    
    
  </entry>
  
</feed>
